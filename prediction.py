import pickle
import random


#transfor the data get from front end to valid input for f_pred()
def create_input(m_pass):
    res = [0*i for i in xrange(len(m_pass))]
    with open('data/maps/feature_map.pkl', 'rb') as input:
        f_map = pickle.load(input)
        for key in m_pass:
            if "\n" in key: # get rid of "\n"
                key = key[:-1]
            index = f_map[key]
            # try:
            value = m_pass[key]
            # except:
            #     print  key + " does not exist"
            res[index] = value
        return res
        
        
#return the prediction in string (label name) using model random forest0
def predict_random_forest0(model_URL, X):
    with open(model_URL, 'rb') as input:
        forest = pickle.load(input)
    with open('data/maps/get_label_map.pkl', 'rb') as input2:
        Array = []
        Array.append(X)
        label = pickle.load(input2)
        print forest.predict(Array)[0]
        
        return label[forest.predict(Array)[0]]

#return the prediction in string (label name) using model random forest1        
def predict_random_forest1(model_URL, X):
    with open(model_URL, 'rb') as input:
        forest = pickle.load(input)
    with open('data/maps/get_label_map.pkl', 'rb') as input2:
        Array = []
        Array.append(X)
        label = pickle.load(input2)
        # print forest.predict(Array)[0]
        
        return label[forest.predict(Array)[0]]

#return the prediction in string (label name) using model decision tree0        
def predict_decision_tree0(model_URL, X):
    with open(model_URL, 'rb') as input:
        clf = pickle.load(input)
    with open('data/maps/get_label_map.pkl', 'rb') as input2:
        Array = []
        Array.append(X)
        label = pickle.load(input2)
        # print forest.predict(Array)[0]
        
        return label[clf.predict(Array)[0]]

#return the prediction in string (label name) using model decision tree0        
def predict_decision_tree1(model_URL, X):
    with open(model_URL, 'rb') as input:
        clf = pickle.load(input)
    with open('data/maps/get_label_map.pkl', 'rb') as input2:
        Array = []
        Array.append(X)
        label = pickle.load(input2)
        # print forest.predict(Array)[0]
        
        return label[clf.predict(Array)[0]]

#front end will call this function
def get_Prediction(model_name, model_URL, m_pass):
    #destribute the request from different models
    print "start"
    if(model_name == "Random_forest_n_estimators=25"):
        print "25"
        return predict_random_forest0(model_URL, create_input(m_pass))
    if(model_name == "Random_forest_n_estimators=50"):
        return predict_random_forest1(model_URL, create_input(m_pass))
    if(model_name == "Decision_tree_min_samples_split=4"):
        return predict_decision_tree0(model_URL, create_input(m_pass))
    if(model_name == "Decision_tree_pre_sort=true"):
        return predict_decision_tree1(model_URL, create_input(m_pass))
    
#unit test
# with open('data/maps/feature_map.pkl', 'rb') as input3:
#     f_map = pickle.load(input3)
#     m_passf = dict()
#     random.seed()
#     for key in f_map:
#         m_passf[key] = random.randint(0, 40)
#     # X = create_input(m_passf)
#     res = get_Prediction("Random_forest_n_estimators=50", "data/models/random_forest_n_estimators_50.pkl",m_passf)
#     print res